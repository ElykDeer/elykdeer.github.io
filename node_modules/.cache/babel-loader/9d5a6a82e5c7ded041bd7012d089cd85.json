{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _cleanArray = _interopRequireDefault(require(\"../utils/cleanArray\"));\n\nvar _sendCursorToEnd = _interopRequireDefault(require(\"../utils/sendCursorToEnd\"));\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal[\"default\"].signature : function (a) {\n  return a;\n};\n\nvar _default = function _default(direction, options) {\n  var history = options.history,\n      historyPosition = options.historyPosition,\n      previousHistoryPosition = options.previousHistoryPosition,\n      terminalInput = options.terminalInput; // BUG: I have to duplicate sendCursorToEnd for each condition, because doing so in a catch-all manner doesn't seem to work at all\n  // Clean potential empty items and reverse order to ease position tracking\n  // (Reverse = starting from the newest first when going up and vice versa)\n\n  var commandHistory = (0, _cleanArray[\"default\"])(history).reverse();\n  var position = historyPosition;\n  var previousPosition = previousHistoryPosition;\n  var terminal = terminalInput.current;\n\n  if (commandHistory.length > 0) {\n    // Only run if history is non-empty and in use\n    switch (direction) {\n      case 'up':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          var latest = commandHistory[0];\n          var first = commandHistory[commandHistory.length - 1];\n          var next = commandHistory[position + 1];\n\n          if (position === null) {\n            // If at no yet defined position, get most recent entry\n            terminal.value = latest;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: 0,\n              previousHistoryPosition: null\n            };\n          } else if (position + 1 === commandHistory.length) {\n            // If the first entry will be reached on this press, get it and decrement position by 1 to avoid confusing downscroll\n            // EXCEPT: If there is only 1 unit in the history, our previous position was actually null, not zero as defined above\n            // Hence why in one-unit histories the previous position has to be set to null, not 0\n            terminal.value = first;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: commandHistory.length - 1,\n              previousHistoryPosition: commandHistory.length === 1 ? null : commandHistory.length - 2\n            };\n          } else {\n            // Normal increment by one\n            terminal.value = next;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: position + 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n\n      case 'down':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          var _latest = commandHistory[0];\n          var empty = '';\n          var _next = commandHistory[position - 1];\n\n          if (position === null || !commandHistory[position]) {\n            // If at initial or out of range, clear (Unix-like behaviour)\n            terminal.value = empty;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else if (position - 1 === -1) {\n            // Clear because user is either pressing up once and is now pressing down again, or is reaching the latest entry\n            if (previousPosition === null || position === 0 && previousPosition === 1) terminal.value = empty;else terminal.value = _latest;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else {\n            // Normal decrement by one\n            terminal.value = _next;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: position - 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n    }\n  }\n};\n/**\r\n * Scrolls command history in a given direction\r\n * @param {String} direction Direction to scroll in ('up' or 'down')\r\n * @param {Object} options\r\n * @param {Array} options.history - Array of previous inputs from the user\r\n * @param {Number} options.historyPosition - Current position in the history\r\n * @param {Number} options.previousHistoryPosition - Previous position in the history\r\n * @param {React.Ref} options.terminalInput - Ref to the terminal input element\r\n */\n\n\nvar _default2 = _default;\nexports[\"default\"] = _default2;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(_default, \"default\", \"C:\\\\Users\\\\LWTech Gaming\\\\Code Projects\\\\react-console-emulator\\\\src\\\\handlers\\\\scrollHistory.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/home/kyle/elyk.dev/node_modules/react-console-emulator/dist/handlers/scrollHistory.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_cleanArray","_sendCursorToEnd","enterModule","reactHotLoaderGlobal","undefined","module","__signature__","signature","a","_default","direction","options","history","historyPosition","previousHistoryPosition","terminalInput","commandHistory","reverse","position","previousPosition","terminal","current","length","latest","first","next","_latest","empty","_next","_default2","reactHotLoader","default","register","leaveModule"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _cleanArray = _interopRequireDefault(require(\"../utils/cleanArray\"));\n\nvar _sendCursorToEnd = _interopRequireDefault(require(\"../utils/sendCursorToEnd\"));\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal[\"default\"].signature : function (a) {\n  return a;\n};\n\nvar _default = function _default(direction, options) {\n  var history = options.history,\n      historyPosition = options.historyPosition,\n      previousHistoryPosition = options.previousHistoryPosition,\n      terminalInput = options.terminalInput; // BUG: I have to duplicate sendCursorToEnd for each condition, because doing so in a catch-all manner doesn't seem to work at all\n  // Clean potential empty items and reverse order to ease position tracking\n  // (Reverse = starting from the newest first when going up and vice versa)\n\n  var commandHistory = (0, _cleanArray[\"default\"])(history).reverse();\n  var position = historyPosition;\n  var previousPosition = previousHistoryPosition;\n  var terminal = terminalInput.current;\n\n  if (commandHistory.length > 0) {\n    // Only run if history is non-empty and in use\n    switch (direction) {\n      case 'up':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          var latest = commandHistory[0];\n          var first = commandHistory[commandHistory.length - 1];\n          var next = commandHistory[position + 1];\n\n          if (position === null) {\n            // If at no yet defined position, get most recent entry\n            terminal.value = latest;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: 0,\n              previousHistoryPosition: null\n            };\n          } else if (position + 1 === commandHistory.length) {\n            // If the first entry will be reached on this press, get it and decrement position by 1 to avoid confusing downscroll\n            // EXCEPT: If there is only 1 unit in the history, our previous position was actually null, not zero as defined above\n            // Hence why in one-unit histories the previous position has to be set to null, not 0\n            terminal.value = first;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: commandHistory.length - 1,\n              previousHistoryPosition: commandHistory.length === 1 ? null : commandHistory.length - 2\n            };\n          } else {\n            // Normal increment by one\n            terminal.value = next;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: position + 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n\n      case 'down':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          var _latest = commandHistory[0];\n          var empty = '';\n          var _next = commandHistory[position - 1];\n\n          if (position === null || !commandHistory[position]) {\n            // If at initial or out of range, clear (Unix-like behaviour)\n            terminal.value = empty;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else if (position - 1 === -1) {\n            // Clear because user is either pressing up once and is now pressing down again, or is reaching the latest entry\n            if (previousPosition === null || position === 0 && previousPosition === 1) terminal.value = empty;else terminal.value = _latest;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else {\n            // Normal decrement by one\n            terminal.value = _next;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: position - 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n    }\n  }\n};\n\n/**\r\n * Scrolls command history in a given direction\r\n * @param {String} direction Direction to scroll in ('up' or 'down')\r\n * @param {Object} options\r\n * @param {Array} options.history - Array of previous inputs from the user\r\n * @param {Number} options.historyPosition - Current position in the history\r\n * @param {Number} options.previousHistoryPosition - Previous position in the history\r\n * @param {React.Ref} options.terminalInput - Ref to the terminal input element\r\n */\nvar _default2 = _default;\nexports[\"default\"] = _default2;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(_default, \"default\", \"C:\\\\Users\\\\LWTech Gaming\\\\Code Projects\\\\react-console-emulator\\\\src\\\\handlers\\\\scrollHistory.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();"]},"metadata":{},"sourceType":"script"}